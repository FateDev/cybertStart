Well, the python was basic and easy, but a new thing I was introduced to was the sockets implementation in Python:

For loops are:
```
for i in range(x,y):
  print(i)
```
Will print all the number between x and y, including x, not including y.

## Files
This `file = open("/example/test.txt", "w")` will open a file in write mode, from that path.
`file.write("Test.\n")` will write that to the file, with a new line character at the end.
`file.close()` will close the file.

To put the contents of the file into a single variables, do: `fileContents = file.read()`, then you can just literally do `prnt(fileContents)` to print the contents.

The other ways to open the file are:
```
w - write only, overwrites file if it exists
r - read only
r+ - read and write
w+ - read and write, but if it exists, it will overwrite it
a - allows you to append to the end of the file
a+ - allows you to append to the end of the file and read the file
```

You can read a file line by line:
```
for line in file:
  print(line)
```
This specifically will read and then print it, line by line.

A better way to do file handling is:
```
with open("file.txt", "r") as file:
  #something
```
Which will mean that you don't need to close it yourself basically, so no chance of you accidentally leaving it open.

## Sockets

First you need to do `import sleep` to import a library to use.

Then you construct either a client or server socket, let's start with client.
`client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)`
AF_INET means you're connecting to an IPv4 IP address, and SOCK_STREAM means you're connecting to a TCP connection rather than UDP.
SOCK_DGRAM is UDP, in which you send one message, get a reply, and the connection terminates.

You then connect to the server:
`client.connect(("IP", PORT_NUMBER))`
You replace IP and PORT_NUMBER with an IP address and a 4 digit port number obviously.
 and stuff
To receive data you do:
`data = client.recv(1024)`
Receives 1024 bytes, the maximum amount that can be received.
And then you can just print it, it'll probably be a string or whatever other response from the server.

Then to make a server it's pretty simple as well:
```
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(("IP", PORT_NUMBER))
server.listen(NUMBER)
```
The 2nd line binds to the specified IP and port number, and the next line is the maximum amount of users it listens to.

Then you need to setup an infinite loop so that it continuously listens for incoming connections:
```
while True:
  connection, address = server.accept() //if the server gets a new connection, save it, and save the connection and its address in those variables
  
  data = connection.recv(1024) //receive 1024 bytes
  
  if len(data) > 0:
    print(data) //prints the data if it is longer than 0
```

Then you can simply do `connection.close()` to close the connection, and `server.close()` to close the server socket.

By the way, Python sockets are by default, in blocking mode, so will wait for a response from, say, recv, before moving on.

## HTTP
To use HTTP requests, you must first do this: `import urllib2`, and then to open a url: `response = urllib2.urlopen("URL:PORT/address etc")`, which is pretty self explanatory.

And then to simply read what there is: `html = response.read()`, and then you can print the `html` variable.

Also you must specify `http` or `https` before the url.

## ASCII
`chr(number)` will give you the ASCII character represented by that number and `ord(character)` will give you the number representing the character.

And `str(number)` will make a number into a string for string operations, like printing it with other strings using `+`

## Regex
Firstly `import re` to use regex.
Then you can make a pattern variable, and use it like this:
`data = re.findall(patternVariable, textToLookThrough`. Then do `print(data[0])` to print the first match.

By the way, the `re.findall(x,y)` returns true if something is found, false otherwise, so can be used directly in if/else statements and loops.

And then you can actually begin to use regex patterns, for example:
`pattern: (.*)` is a pattern which, when applied, will look for anything with the phrase `pattern: ` in it, and then the inside of brackets acts as regex, with the `.` meaning any character, and the `*` meaning any number of times, so in essence, it will print out anything after the phrase `pattern: ` (including the space). To make sure that the `(...)` aren't processed as regex, you can 'escape' them by use of backslashes.
This means it will just print out whatever it matches, rather than anything after or whatever.

As a summary for what you can do inside the brackets:
```
\d is any digit
\D is any non-digit character
. is any character
\. is a period/full stop
[abc] is only the letters a, b, or c
[^abc] is not a, b, or c
[0-9] is any number 0 to 9
\w is any alphanumeric character (letters or numbers)
\W is any non-alphanumeric character (not letters or numbers)
{m} is how many repetitions, i.e replace m with the repetitions
{m,n} is the range of repetitions, so from m to n repetitions
* is zero or more repetitions
+ is one or more repetitions
? is an optional character
\s is any whitespace
\S is any non-whitespace character
^...$ is the starting and ending pair of characters, put a sentence in between it to look for that sentence, ^ is the beginning of the line, $ is the end
(...) is the capture group thing, which allows you to capture specifically whatever is in those brackets, and so allows you to make more complex regex queries
(a(bc)) is the capture sub-group, which allows you to capture 2 different things at once, say from `Jan 1975` it allows you to capture `Jan 1975` in the `a` part of the expression and `1975` in the `bc` part of the expression
(.*) is the capture all query
(abc|def) captures `abc` or `def`, if both are present, captures both
```
